import type { Plugin } from 'vite';
import { parseFile } from 'webmcp-instrument-engine/parser';
import { buildProposals } from 'webmcp-instrument-engine/proposal';
import { generateMCPCodeSync } from 'webmcp-instrument-engine/generator';
import { readFileSync, existsSync } from 'fs';
import fg from 'fast-glob';
const { globSync } = fg;

export interface WebMCPPluginOptions {
    include?: string[];
    llm?: string; // e.g. 'openai'
    /**
     * How to inject the virtual module into the app.
     * - `'html'` (default) — injects `<script src="/@id/virtual:webmcp-tools">`
     *   via `transformIndexHtml`. Works universally; Vite resolves the `/@id/`
     *   URL through its module graph so no CORS issues.
     * - `'entry'` — prepends `import 'virtual:webmcp-tools'` to the app's entry
     *   file via a `transform` hook. Use this if `'html'` causes issues in your
     *   setup (e.g. SSR builds). Defaults to matching `src/main.(tsx|ts|jsx|js)`;
     *   customise with the `entry` option.
     */
    inject?: 'html' | 'entry';
    /**
     * Custom entry file pattern when using `inject: 'entry'`.
     * Can be a RegExp or a string (matched as a suffix against the file path).
     * @default /\/src\/main\.(tsx?|jsx?)(\?.*)?$/
     */
    entry?: RegExp | string;
}

const VIRTUAL_MODULE_ID = 'virtual:webmcp-tools';
const RESOLVED_VIRTUAL_MODULE_ID = '\0' + VIRTUAL_MODULE_ID;

export default function webmcpPlugin(options: WebMCPPluginOptions = {}): Plugin {
    const includeGlobs = options.include || ['src/**/*.tsx', 'src/**/*.jsx', 'src/**/*.vue'];
    const injectMode = options.inject ?? 'html';
    let generatedCodes: Map<string, string> = new Map();

    function scanAndGenerateAll() {
        generatedCodes.clear();
        const cwd = process.cwd();
        const files = includeGlobs.flatMap(g => globSync(g, { absolute: true, cwd }));
        for (const file of files) {
            if (existsSync(file)) {
                generateForFile(file);
            }
        }
    }

    function generateForFile(file: string, context: 'scan' | 'hmr' = 'scan') {
        try {
            const source = readFileSync(file, 'utf-8');
            const analysis = parseFile(source, file);
            const proposals = buildProposals(analysis);

            // Filter out excluded tools
            const validProposals = proposals.filter(p => p.risk !== 'excluded');

            if (validProposals.length === 0) {
                generatedCodes.delete(file);
                return;
            }

            const code = generateMCPCodeSync(validProposals, {
                format: 'esm',
                framework: analysis.framework
            });
            generatedCodes.set(file, code);

            const shortPath = file.replace(process.cwd().replace(/\\/g, '/'), '.').replace(/\\/g, '/');
            if (context === 'scan') {
                console.log(`[WebMCP] Scanned: ${shortPath} (${validProposals.length} tool${validProposals.length !== 1 ? 's' : ''} proposed)`);
            } else {
                console.log(`[WebMCP] Hot update: ${shortPath}`);
            }
        } catch (err) {
            // Ignored non-parseable files
        }
    }

    return {
        name: 'vite-plugin-webmcp',
        enforce: 'pre',

        buildStart() {
            scanAndGenerateAll();
        },

        resolveId(id) {
            if (id === VIRTUAL_MODULE_ID) {
                return RESOLVED_VIRTUAL_MODULE_ID;
            }
            // Handle /@id/ prefix — in dev Vite strips it automatically, but in
            // build mode the HTML plugin may pass the raw src attribute through
            // resolveId. Normalise and match so both modes work.
            const normalized = id.replace(/\\/g, '/');
            if (
                normalized === `/@id/${VIRTUAL_MODULE_ID}` ||
                normalized.endsWith(`/@id/${VIRTUAL_MODULE_ID}`)
            ) {
                return RESOLVED_VIRTUAL_MODULE_ID;
            }
        },

        load(id) {
            if (id === RESOLVED_VIRTUAL_MODULE_ID) {
                const codes = Array.from(generatedCodes.values()).join('\n\n');
                return `// Auto-generated by webmcp-instrument-vite — do not edit\n${codes}`;
            }
        },

        handleHotUpdate({ file, server }) {
            if (includeGlobs.some(g => file.match(new RegExp(g.replace('**/*', '.*').replace('*', '.*'))))) {
                generateForFile(file, 'hmr');

                // Invalidate the virtual module so Vite re-loads it
                const mod = server.moduleGraph.getModuleById(RESOLVED_VIRTUAL_MODULE_ID);
                if (mod) {
                    server.moduleGraph.invalidateModule(mod);
                }

                server.ws.send({
                    type: 'full-reload',
                    path: '*'
                });
            }
        },

        // ── Primary injection: HTML <script src="/@id/..."> ──────────────
        // Vite resolves /@id/ URLs through its module graph, so the virtual
        // module goes through resolveId → load correctly. No inline import,
        // no CORS issues.
        transformIndexHtml() {
            if (injectMode !== 'html') return;
            return [
                {
                    tag: 'script',
                    attrs: {
                        type: 'module',
                        src: `/@id/${VIRTUAL_MODULE_ID}`
                    },
                    injectTo: 'body' as const
                }
            ];
        },

        // ── Fallback injection: prepend import to app entry ──────────────
        // Activated with inject: 'entry'. Works by prepending the virtual
        // module import to the app's entry file so it goes through Vite's
        // normal module graph resolution.
        transform(code, id) {
            if (injectMode !== 'entry') return;

            const normalizedId = id.replace(/\\/g, '/');
            const entryPattern = options.entry
                ? typeof options.entry === 'string'
                    ? new RegExp(
                        options.entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') +
                        '(\\?.*)?$'
                    )
                    : options.entry
                : /\/src\/main\.(tsx?|jsx?)(\?.*)?$/;

            if (entryPattern.test(normalizedId)) {
                // Don't inject twice
                if (code.includes(VIRTUAL_MODULE_ID)) return;
                return {
                    code: `import '${VIRTUAL_MODULE_ID}';\n${code}`,
                    map: null
                };
            }
        }
    };
}

