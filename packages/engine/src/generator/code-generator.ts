import type { ToolProposal, OutputFormat, FrameworkType, LLMAdapter } from '../types.js';
import { FRAMEWORK_HELPERS } from './framework-helpers.js';
import { generateHandlerWithLLM, buildTemplateHandler } from './handler-generator.js';
import { createHash } from 'node:crypto';
import { getCachedHandler, setCachedHandler } from '../cache/file-cache.js';

export interface GenerateOptions {
  format: OutputFormat;
  framework: FrameworkType;
  llm?: LLMAdapter;
}

// ── Async path — with or without LLM ─────────────────────────

/**
 * Generate .mcp.js content for the selected tools.
 * If llm is provided and is not the NoneAdapter, calls the LLM per tool.
 * Otherwise falls back to template generation.
 */
export async function generateMCPCode(
  tools: ToolProposal[],
  options: GenerateOptions,
): Promise<string> {
  const llm = options.llm;
  // Duck-type check: NoneAdapter identifies itself by name
  const isTemplate = !llm || llm.name === 'Template-only (no LLM)';

  const toolRegistrations: string[] = [];

  for (const tool of tools) {
    let handlerBody: string;

    if (isTemplate) {
      handlerBody = buildTemplateHandler(tool);
    } else {
      const cached = getCachedHandler(tool);
      if (cached) {
        handlerBody = cached;
      } else {
        handlerBody = await generateHandlerWithLLM(tool, llm!);
        if (handlerBody) {
          setCachedHandler(tool, handlerBody);
        }
      }
    }

    toolRegistrations.push(buildToolRegistration(tool, handlerBody));
  }

  const sourceHash = createHash('sha256')
    .update(tools.map(t => t.name).join(','))
    .digest('hex')
    .slice(0, 12);

  const modeComment = isTemplate
    ? '// Generated without LLM — set OPENAI_API_KEY or run `gh auth login` for smarter handlers'
    : `// Generated with: ${llm!.name}`;

  return formatOutput(toolRegistrations, sourceHash, modeComment);
}

// ── Sync path — template only ─────────────────────────────────

/**
 * Synchronous, template-only version.
 * Used when async generation is not needed (e.g. tests, server streaming).
 */
export function generateMCPCodeSync(
  tools: ToolProposal[],
  _options: Omit<GenerateOptions, 'llm'>,
): string {
  const toolRegistrations = tools.map(tool =>
    buildToolRegistration(tool, buildTemplateHandler(tool))
  );

  const hash = tools.map(t => t.name).join('+');
  return formatOutput(toolRegistrations, hash, '// Template mode (sync)');
}

// ── Shared helpers ────────────────────────────────────────────

function buildToolRegistration(tool: ToolProposal, handlerBody: string): string {
  const propsJSON = JSON.stringify(tool.inputSchema.properties, null, 4)
    .replace(/^/gm, '    ')
    .trimStart();

  return `
const tool_${tool.name} = {
  name: ${JSON.stringify(tool.name)},
  description: ${JSON.stringify(tool.description)},
  inputSchema: {
    type: "object",
    properties: ${propsJSON},
    required: ${JSON.stringify(tool.inputSchema.required)}
  },
  handler: async (params) => {
${indentBody(handlerBody, 4)}
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_${tool.name});
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_${tool.name});
}`;
}

function formatOutput(toolRegistrations: string[], sourceHash: string, modeComment: string): string {
  return `// Auto-generated by WebMCP Auto-Instrumentor
// Do not edit manually — re-run \`webmcp instrument\` to regenerate
// Source hash: ${sourceHash}
${modeComment}
// Requires: webmcp-instrument-runtime — https://github.com/epeer1/WebMCP2
${FRAMEWORK_HELPERS}
${toolRegistrations.join('\n')}
`;
}

function indentBody(body: string, spaces: number): string {
  const indent = ' '.repeat(spaces);
  return body
    .split('\n')
    .map(line => (line.trim() ? indent + line : ''))
    .join('\n');
}
