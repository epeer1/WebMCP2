import type { ToolProposal, OutputFormat, FrameworkType, LLMAdapter } from '../types.js';
import { FRAMEWORK_HELPERS } from './framework-helpers.js';
import { generateHandlerWithLLM, buildTemplateHandler } from './handler-generator.js';
import { NoneAdapter } from '../llm/none-adapter.js';
import { createHash } from 'node:crypto';

export interface GenerateOptions {
  format: OutputFormat;
  framework: FrameworkType;
  llm?: LLMAdapter;
  sourceExcerpt?: string;
}

/**
 * Generate the final .mcp.js file content for the selected tools.
 * With LLM: calls the LLM to generate each handler body.
 * Without LLM: uses template-based generation from AST data.
 */
export async function generateMCPCode(
  tools: ToolProposal[],
  options: GenerateOptions,
): Promise<string> {
  const llm = options.llm ?? new NoneAdapter();
  const useTemplate = llm instanceof NoneAdapter;

  const toolRegistrations: string[] = [];

  for (const tool of tools) {
    // Generate handler body
    const handlerBody = useTemplate
      ? buildTemplateHandler(tool)
      : await generateHandlerWithLLM(tool, llm, options.sourceExcerpt);

    const propsJSON = JSON.stringify(tool.inputSchema.properties, null, 4)
      .replace(/^/gm, '    ')  // indent
      .trimStart();

    const requiredJSON = JSON.stringify(tool.inputSchema.required);

    toolRegistrations.push(`
window.mcp.registerTool({
  name: ${JSON.stringify(tool.name)},
  description: ${JSON.stringify(tool.description)},
  inputSchema: {
    type: "object",
    properties: ${propsJSON},
    required: ${requiredJSON}
  },
  handler: async (params) => {
${indentBody(handlerBody, 4)}
  }
});`);
  }

  // Source hash for idempotency detection
  const sourceHash = tools.length > 0
    ? createHash('sha256')
      .update(tools.map(t => t.name).join(','))
      .digest('hex')
      .slice(0, 12)
    : 'no-tools';

  const modeComment = useTemplate
    ? '// Generated without LLM — add OPENAI_API_KEY or run `gh auth login` for better handlers'
    : `// Generated with: ${llm.name}`;

  return `// Auto-generated by WebMCP Auto-Instrumentor
// Do not edit manually — re-run \`webmcp instrument\` to regenerate
// Source hash: ${sourceHash}
${modeComment}
// Requires: @webmcp/runtime — https://github.com/user/webmcp
${FRAMEWORK_HELPERS}
${toolRegistrations.join('\n')}
`;
}

// ── Sync overload for template-only generation (no async needed) ──

/**
 * Synchronous version — uses template generation only (no LLM).
 * Used by the Phase 0/1 CLI flow before LLM integration.
 */
export function generateMCPCodeSync(
  tools: ToolProposal[],
  options: Omit<GenerateOptions, 'llm'>,
): string {
  const toolRegistrations = tools.map(tool => {
    const handlerBody = buildTemplateHandler(tool);
    const propsJSON = JSON.stringify(tool.inputSchema.properties, null, 4)
      .replace(/^/gm, '    ')
      .trimStart();

    return `
window.mcp.registerTool({
  name: ${JSON.stringify(tool.name)},
  description: ${JSON.stringify(tool.description)},
  inputSchema: {
    type: "object",
    properties: ${propsJSON},
    required: ${JSON.stringify(tool.inputSchema.required)}
  },
  handler: async (params) => {
${indentBody(handlerBody, 4)}
  }
});`;
  });

  return `// Auto-generated by WebMCP Auto-Instrumentor (template mode)
// Source hash: ${tools.map(t => t.name).join('+')}
${FRAMEWORK_HELPERS}
${toolRegistrations.join('\n')}
`;
}

function indentBody(body: string, spaces: number): string {
  const indent = ' '.repeat(spaces);
  return body
    .split('\n')
    .map(line => (line.trim() ? indent + line : ''))
    .join('\n');
}
