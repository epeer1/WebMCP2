// Auto-generated by WebMCP Auto-Instrumentor
// Do not edit manually — re-run `webmcp instrument` to regenerate
// Source hash: 04ceb4caaed1
// Generated with: GitHub Models (gpt-4o-mini)
// Requires: webmcp-instrument-runtime — https://github.com/epeer1/WebMCP2

// ── WebMCP DOM helpers ──────────────────────────────────────
function __mcpFind(selectors) {
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    if (el) return el;
  }
  throw new Error('[WebMCP] Element not found matching any of: ' + selectors.join(', '));
}

function __mcpSetValue(selectors, value) {
  const el = __mcpFind(selectors);
  // Use native setter to bypass React's value tracking
  const proto = el instanceof HTMLTextAreaElement
    ? HTMLTextAreaElement.prototype
    : HTMLInputElement.prototype;
  const nativeSetter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
  if (nativeSetter) {
    nativeSetter.call(el, value);
  } else {
    el.value = value;
  }
  el.dispatchEvent(new Event('input', { bubbles: true }));
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetChecked(selectors, checked) {
  const el = __mcpFind(selectors);
  const nativeSetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'checked')?.set;
  if (nativeSetter) nativeSetter.call(el, checked);
  else el.checked = checked;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetSelect(selectors, value) {
  const el = __mcpFind(selectors);
  el.value = value;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpClick(selectors) {
  const el = __mcpFind(selectors);
  el.click();
}
// ────────────────────────────────────────────────────────────


const tool_delete_selected = {
  id: "44d5b7d5c527",
  name: "delete_selected",
  description: "Trigger: Delete Selected",
  inputSchema: {
    type: "object",
    properties: {},
    required: []
  },
  handler: async (params) => {
    try {
        alert(`Deleted ${selected.size} users: ${Array.from(selected).join(', ')}`);
        setSelected(new Set());
        __mcpClick(["Delete Selected", "button:Delete Selected", "button"]);
        return { success: true, message: 'Users deleted successfully.' };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_delete_selected);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_delete_selected);
}

const tool_manage_user_username = {
  id: "58c84f7ed78e",
  name: "manage_user_username",
  description: "Trigger: `Manage user ${user.name}`",
  inputSchema: {
    type: "object",
    properties: {},
    required: []
  },
  handler: async (params) => {
    try {
        alert(`Managing user ${user.name}`);
        __mcpClick(["button"]);
        return { success: true, message: `Successfully managed user ${user.name}` };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_manage_user_username);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_manage_user_username);
}
