// Auto-generated by WebMCP Auto-Instrumentor
// Do not edit manually — re-run `webmcp instrument` to regenerate
// Source hash: 2208e84b33e0
// Generated with: GitHub Models (gpt-4o-mini)
// Requires: webmcp-instrument-runtime — https://github.com/epeer1/WebMCP2

// ── WebMCP DOM helpers ──────────────────────────────────────
function __mcpFind(selectors) {
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    if (el) return el;
  }
  throw new Error('[WebMCP] Element not found matching any of: ' + selectors.join(', '));
}

function __mcpSetValue(selectors, value) {
  const el = __mcpFind(selectors);
  // Use native setter to bypass React's value tracking
  const proto = el instanceof HTMLTextAreaElement
    ? HTMLTextAreaElement.prototype
    : HTMLInputElement.prototype;
  const nativeSetter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
  if (nativeSetter) {
    nativeSetter.call(el, value);
  } else {
    el.value = value;
  }
  el.dispatchEvent(new Event('input', { bubbles: true }));
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetChecked(selectors, checked) {
  const el = __mcpFind(selectors);
  const nativeSetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'checked')?.set;
  if (nativeSetter) nativeSetter.call(el, checked);
  else el.checked = checked;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetSelect(selectors, value) {
  const el = __mcpFind(selectors);
  el.value = value;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpClick(selectors) {
  const el = __mcpFind(selectors);
  el.click();
}
// ────────────────────────────────────────────────────────────


const tool_save_changes_settings_modal = {
  id: "50cc5c2e9107",
  name: "save_changes_settings_modal",
  description: "Save changes the form with: https://..., retryCount",
  inputSchema: {
    type: "object",
    properties: {
        "webhook_url": {
            "type": "string",
            "description": "https://..."
        },
        "retry_count": {
            "type": "number",
            "description": "number field"
        }
    },
    required: []
  },
  handler: async (params) => {
    try {
        __mcpSetValue(["#webhookUrl","input[type=\"url\"]"], webhook_url);
        __mcpSetValue(["#retryCount","input[type=\"number\"]"], retry_count);
        __mcpClick(["input[type=\"submit\"]"]);
        return { success: true, message: 'Changes saved successfully.' };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_save_changes_settings_modal);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_save_changes_settings_modal);
}

const tool_configure_webhook_settings = {
  id: "64a26c076b94",
  name: "configure_webhook_settings",
  description: "Trigger: Configure Webhook Settings",
  inputSchema: {
    type: "object",
    properties: {},
    required: []
  },
  handler: async (params) => {
    try {
        // Assuming there are input fields to fill, use __mcpSetValue for each
        // Example: __mcpSetValue(["#inputField1"], paramValue1);

        // Trigger the action
        await __mcpClick(["/* TODO: add id to button */"]);
        return { success: true, message: 'Webhook settings configured successfully.' };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_configure_webhook_settings);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_configure_webhook_settings);
}
