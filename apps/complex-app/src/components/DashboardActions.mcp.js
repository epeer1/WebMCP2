// Auto-generated by WebMCP Auto-Instrumentor
// Do not edit manually — re-run `webmcp instrument` to regenerate
// Source hash: 04fc975afc41
// Generated with: GitHub Models (gpt-4o-mini)
// Requires: webmcp-instrument-runtime — https://github.com/epeer1/WebMCP2

// ── WebMCP DOM helpers ──────────────────────────────────────
function __mcpFind(selectors) {
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    if (el) return el;
  }
  throw new Error('[WebMCP] Element not found matching any of: ' + selectors.join(', '));
}

function __mcpSetValue(selectors, value) {
  const el = __mcpFind(selectors);
  // Use native setter to bypass React's value tracking
  const proto = el instanceof HTMLTextAreaElement
    ? HTMLTextAreaElement.prototype
    : HTMLInputElement.prototype;
  const nativeSetter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
  if (nativeSetter) {
    nativeSetter.call(el, value);
  } else {
    el.value = value;
  }
  el.dispatchEvent(new Event('input', { bubbles: true }));
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetChecked(selectors, checked) {
  const el = __mcpFind(selectors);
  const nativeSetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'checked')?.set;
  if (nativeSetter) nativeSetter.call(el, checked);
  else el.checked = checked;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpSetSelect(selectors, value) {
  const el = __mcpFind(selectors);
  el.value = value;
  el.dispatchEvent(new Event('change', { bubbles: true }));
}

function __mcpClick(selectors) {
  const el = __mcpFind(selectors);
  el.click();
}
// ────────────────────────────────────────────────────────────


const tool_restart_main_service = {
  id: "8a3052298650",
  name: "restart_main_service",
  description: "Trigger: Restart Main Service",
  inputSchema: {
    type: "object",
    properties: {},
    required: []
  },
  handler: async (params) => {
    try {
        setStatus('Restarting...');
        await __mcpClick(["[aria-label=\"Restart Main Service\"]"]);
        setTimeout(() => setStatus('Operational'), 2000);
        return { success: true, message: 'Main service restarted successfully.' };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_restart_main_service);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_restart_main_service);
}

const tool_flush_redis_cache_database = {
  id: "eb5e2ec0770d",
  name: "flush_redis_cache_database",
  description: "Trigger: Flush Redis Cache Database",
  inputSchema: {
    type: "object",
    properties: {},
    required: []
  },
  handler: async (params) => {
    try {
        __mcpClick(["[aria-label=\"Flush Redis Cache Database\"]"]);
        return { success: true, message: 'Redis Cache Database flushed successfully.' };
    } catch (err) {
        return { success: false, message: err.message };
    }
  }
};

if (typeof navigator !== 'undefined' && 'modelContext' in navigator) {
  navigator.modelContext.registerTool(tool_flush_redis_cache_database);
} else {
  window.mcp = window.mcp || { registerTool: () => {} };
  window.mcp.registerTool(tool_flush_redis_cache_database);
}
